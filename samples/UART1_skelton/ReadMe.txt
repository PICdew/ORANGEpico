---------------------------------------------------------------------
	PIC32MX 用 LED blinker サンプル
---------------------------------------------------------------------

■ 概要

- PIC32MX で LED 点滅、およびUART1によるシリアルポート・エコーバックを行います。

- libcと簡易なprintfを含んでいますので、開発開始時のスケルトンとして利用可能です。

- Linux / Windows どちらの環境でもビルドできるようにしてあります。



■ 配線         PIC32MX225F128B 8MHz水晶使用.


                3.3V
                 |
                 *------10Ω--------------+
                10k                       |
                 |       ___    ___       | 0.1u
   ラ   -->  ----*-MCLR [1  |__| 28] AVDD-*-||---GND
   イ   -->  --PGD3/RA0 [2       27] AVSS--------GND  LED
   ター -->  --PGC3/RA1 [3       26] RB15--1kΩ-------|＞|--GND
                    RB0 [4       25] RB14
                    RB1 [5       24] RB13
               SDA2/RB2 [6       23] 
               SCL2/RB3 [7       22] 
    Xtal     GND----Vss [8       21]          +10uF
 +-----------------OSC1 [9       20] Vcap------||---GND
 *--|□|--*--------OSC2 [10      19] Vss------------GND
 |  8MHz  |    U1TX/RB4 [11      18] RB9                        *--10k------3.3V
 22pF    22pF  U1RX/RA4 [12      17] RB8                        |
 |        |   3.3v--Vdd [13      16] RB7 -----------------------*--BOOT_SW--GND
 |        |         RB5 [14      15] 
 GND    GND              ~~~~~~~~~~


-  対応PICは MX220 以外に、MX250 , MX170 などもOKです。(同じHEXが使用できます)
-  RB7にBOOT_SW , MCLRにRESET_SWを実装してください。
-  PIC32MX220F032B の RB15 に接続されたLED を点滅します。


            
■ 開発環境 構築
            
- （１）Windows XP / Vista / 7 / 8.1 / 10 もしくは UbuntuなLinux のどれかを用意します。(64bit OK)
        （Ubuntuである必要はありませんがあまりに非力なディストリの場合ビルド環境には向きません）

- （２）Pinguino-11 をダウンロードしてインストールします。
        http://www.pinguino.cc/download.php


■ コンパイル方法

-    make を実行してください。

■ ファームウェアHEXの書き込み方法

- uart_bootloaderを想定しています。
  
  w.bat を起動すると書き込んだ後、実行します。
  
- 各種の書き込み方法は下記ＨＰを参照してください。
  http://hp.vector.co.jp/authors/VA000177/html/PIC32MX.html

- PICKit3で書き込む場合は、main32.hex のかわりに pickit3.hex を書き込んでください。



■ 動作確認方法

- LEDが点滅していれば成功です。

- uart_bootloaderを使用の場合は、元々LEDが点滅していますので
  LED点滅速度が変われば成功です。

- LED点滅と並行して、UARTの文字エコーバックも実行されています。
 （ボーレートはuart_bootloaderと同じ500kBPSです）

- Pinguinoのスケッチやアプリケーションを書き込む場合は、
  uartboot/hostpc/uartflash32.exe -r main32.hex
  のようにして書き込みます。(-rオプションで実行まで行います)

- BOOT_SWはオープンでuart bootloaderが起動し、クローズでユーザープログラム
  が起動するようになっています。(UBW32と逆の論理になっています)
  通常の開発時は、リセットボタンのみでスケッチの再書き込みが行えます。

- 基板をアプリ単体起動で使用したい場合は、BOOT_SWを押ボタン式ではなくジャンパー
  のようなものにして、クローズすると良いです。


■ ファームウェアの動作説明

- UARTから操作しますが、コマンドライン上は、Pinguino4.X 付属の mphidflash.exe 互換
 （予定）です。

- RESETあるいは電源投入時、RB7に接続されたBOOT_SWがOFFであれば BOOTLOADERモード
　になります。

- BOOTLOADERモードのときは U1RX/U1TXのシリアルポートを経由して、PCからのコマンド
  を待ちます。

- パソコンから uartflash32.exe を実行すると、指定されたHEXファイルを自分自身の
  9D00_0000〜9D00_7FFFの領域に書き込んだ後、0x1000番地単位で開始アドレスをサーチ
  して、その開始アドレスへ分岐します。

- このような動作なので、例えば9D00_4000番地スタートのHEXファイルでも起動させること
  が可能です。
  
- HEXファイルが全く書き込まれていない状態ではBOOT_SWのON/OFF如何にかかわらず、
  BOOTLOADERモードになります。

- BOOTLOADERモードのときは電源投入するとRB15に繋がっているLEDを点滅します。

- BOOT_SWを押して、RESETあるいは電源投入した場合は、書き込んだHEXファイルのファーム
　ウェアのほうが起動します。

注意：

  BOOT_SWの(ON/OFF)論理はUBW32と逆になっています。変更したい場合は、HardwareProfile.hの
  #define	Boot_SW_POLARITY	1		// If not PRESSED , Then Run Sketch Program (UBW32 Compat)
  に変更してください。


■ 拡張機能について。

（１）ユーザーエリアを32kBに拡張しています。
	  また、さまざまな開始番地のアプリを自動的にサーチします。

	以下のアドレスから開始するアプリケーションを起動できます。
	（アドレスの若い方からサーチ）
      9D00_0000		28k
      9D00_1000		28k
      9D00_2000		24k
      9D00_3000		20k
      9D00_4000		16k

    アプリケーションが用意する割り込みベクターは通常なら先頭4kBにあります。
    その場合、割り込みベクターのオフセット０には何も書かない(0xFFFFFFFF)か
    あるいは、リセット処理への分岐命令を置いてください。
    

（３）以下のコマンドを用意しています。

#define GET_DATA					    0x07	// RAMやPORTからデータを読み込む. 最大56byteまで.
												// 4の倍数サイズであれば intでアクセス. そうでない
												// 場合はmemcpy()を使用してアクセス.

#define PUT_DATA					    0x09	// GET_DATAの逆で、RAMやPORTにデータを書き込む.

#define EXEC_CODE					    0x0a	// 指定アドレスに分岐する.

コマンドのテストルーチンは hostpc/ 以下にあります。






■ メモリーマップ（全体）

PIC32のメモリーマップです。
- 物理割り当てされているエリアは 0000_0000 〜 2000_0000 の512MBです。
- 物理割り当てされている512MBと全く同じものが KSEG0とKSEG1にもマップされます。
- KSEG0とKSEG1の違いはキャッシュ無効/有効で分けられています。

FFFF_FFFF +---------------+
          |               |
          | Reserved      |
          |               |
C000_0000 +---------------+
          | KSEG1(論理)   | Cacheなし.
A000_0000 +---------------+
          | KSEG0(論理)   | Cacheあり.
8000_0000 +---------------+
          |               |
          | Reserved      |
          |               |
          |               |
          |               |
2000_0000 +---------------+
          | 物理メモリー  | ROM/RAM/PORT
0000_0000 +---------------+



■ メモリーマップ（Flash ROM/RAM領域）

A000_1FFF +---------------+
          |               |
          |   SRAM (8kB)  |
          |               |
A000_0000 +---------------+

(BFC00BFF)
9FC0_0BFF +---------------+
          |BOOT Flash(3kB)| RESET直後の開始番地はBFC0_0000です。
9FC0_0000 +---------------+ Config Fuseは BFC0_0BF0〜BFC0_0BFFの16byteです。
(BFC00000)                  割り込みベクターもBOOT Flash内に置かれます。

9D00_7FFF +---------------+
          |               |
          |Program Flash  |
          |    (32kB)     |
          |               |
9D00_0000 +---------------+



■ ツール

- xdump   :  バイナリーファイルを１６進数でダンプする.

- hex2dump:  HEXファイルを１６進数ダンプリストにする. / HEXファイルのコマンド05をフィルタリングする。

- hex2pickit3:  HEXファイルを PICKit3で書き込めるメモリー空間のHEXに変換する.

- pic32prog.exe : PicKit2を経由してPIC32MXにHEXファイルを書き込む.




■ 謝辞

  pic32mxやpic32progについてのノウハウの多くをすzさんのＨＰにて勉強させていただきました。
  ここに感謝の意を表します。ありがとうございました。


